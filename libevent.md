# 掌握libevent 网络库
## 服务端时间构成和网络编程关注的问题
### 网络编程关注的问题
- 连接建立的问题
  **三次握手**  accept   connect
> 1. 当客户端发送第一次发送SYN请求时候，服务端将该连接加入半连接队列（SYN队列）
> 2. 服务端回应SYN+ACK
> 3. 客户端返回ACK 请求，服务端将连接从半连接队列移除，然后创建新的完全连接，并将其添加到全连接（accept 队列），等待进程调用accept 函数时将连接从全连接队列取出。

- 连接断开的问题
  **四次挥手**
  主动：close  
  被动：
    `通过io函数检测`
  1. read = 0（server的读端关闭）  
  2. write = -1 && errno = EPIPE（server的写段关闭）
- 消息到达的问题
  是否能从server端的读缓冲区正常的完整的读到数据
- 消息发送完毕
  是否成功将数据写到写缓冲区，**到底有无成功发送到对端是linux 内核协议栈应该关注的**

### libevent —— an event notification library（事件通知库）
**哪些事件驱动服务器逻辑**
1. 网络事件
2. 定时事件（心跳包，定时事件等）
3. 信号事件
> libevent 主要就是包装这三个事件
- 网络编程：
  1. 检测io：
    - 连接建立时检测全连接队列里是否有连接，如果有调用accept() 取出队列里的连接
    - 连接断开时检测S端的读写锁是否关闭
    - 消息到达时检测读缓冲区内是否有数据，如果有就调用read() 读取数据
    - 消息发送时检测写缓冲区内是否可以发送数据
  2. 操作io
> 在各种io操作中都需要对一个fd 进行处理，这就意味着每一条连接都需要有一个线程
- **libevent 封装了reactor 网络模型**
  **reactor？**
  1. 事件处理模式         --将对io的处理转化成对事件的处理
  2. 处理并发的服务请求    --io多路复用 + 非阻塞io
  3. 多路复用            --同上
  4. 同步派发
> 理解过程：
> - listenfd 交给epoll 进行管理，当listenfd 检测到全连接队列有数据（连接），就调用aceept_cb( 全程: accept_callback ) 进行io 操作
> - aceept_cb 是对accept 的封装，函数内部即是调用了accept()
> - epoll_wait(epfd, events, size, timeout) 的本质和read(fd, buf, size) 差不多，e_w即是将内核中的就绪事件拷贝到用户态，read即是将内核中读缓冲区的数据拷贝到用户态的buff中，e_w的timeout 是指在规定的时间内是否有网络事件被触发。
> - **为什么用户层需要读写缓冲区？**
>   - 因为我们在利用tcp传输数据时，我们需要处理粘包和拆包。而tcp 是不知道我们用户是怎么界定数据包，在我们收到tcp的数据包后，将其存到读缓冲区，根据我们界定数据包的格式去解析数据包；用户无法感知内核的写缓冲区，设立一个用户层的写缓冲区，写成功了删除，写失败了保存至下次再写入。

## libevent 解决了网络编程的哪些问题
- 封装了io操作和io检测的API，让程序员可以只关心异常的类型和传入的参数

## memcached 是如何使用libevent
### memcached 
- 多线程架构
- memcached作为高速运行的分布式缓存服务器，具有以下的特点：
  - 协议简单
  - 基于libevent的事件处理
  - 内置内存存储方式
  - memcached不互相通信的分布式
> - **事件处理**
>   libevent是个程序库，它将Linux的epoll、BSD类操作系统的kqueue等事件处理功能封装成统一的接口。即使对服务器的连接数增加，也能发挥O(1)的性能。memcached使用这个libevent库，因此能在Linux、BSD、Solaris等操作系统上发挥其高性能。
> - **存储方式**
>   为了提高性能，memcached中保存的数据都存储在memcached内置的内存存储空间中。由于数据仅存在于内存中，因此重启memcached、重启操作系统会导致全部数据消失。另外，内容容量达到指定值之后，就基于LRU(Least Recently Used)算法自动删除不使用的缓存。memcached本身是为缓存而设计的服务器，因此并没有过多考虑数据的永久性问题。
> - **通信分布式**
>   memcached尽管是“分布式”缓存服务器，但服务器端并没有分布式功能。各个memcached不会互相通信以共享信息。那么，怎样进行分布式呢？这完全取决于客户端的实现。
